; THIS CODE IS REPRODUCED FROM THE BOOK
; "Build your own Z80 Computer", By Steve Ciarcia
; Originally published by Byte Books.
;
; It was released as a public electronic copy by Circuit Cellar Ink Magazine
; Contact circuitcellar@circuitcellar.com for clarification
;
; I have had to type this by hand, and made every effort to reproduce
; the code exactly as published.  The only changes were to suit the 
; Savannah Z80 Assembler (z80asm).  Spelling issues were deliberately
; left IN the code.
;
; Chris Moran, October 2016
;
;
;THE FOLLOWING EQUATES ARE USED
;AS OPERATING SYSTEM CONSTANTS
;
ZERO:		EQU 	0
ONE:		EQU 	1
TWO:		EQU 	2
THREE:		EQU 	3
FOUR: 		EQU 	4
FIVE:		EQU 	5
EIGHT:		EQU		8
ADDIS1:		EQU		5				;MSDS ADDRESS DISPLAY PORT
ADDIS2:		EQU		6				;LSDS ADDRESS DISPLAY PORT
DATDIS:		EQU		7				;DATA DISPLAY PORT
EXECC:		EQU		16			;EXEC KEY
NEXTC:		EQU		32			;NEXT KEY
UARTIO:		EQU		2				;UART I/O PORT
UARTST:		EQU		3				;UART STATUS PORT
KEYPT:		EQU		0				;KEYBOARD INPUT PORT
;
;
			ORG	0x0000
;
;
;COLD SETS THE OPERATING SYSTEM STACK POINTER
;AND ENTERS THE COMMAND RECOGNITION MODULE
;
;
COLD:		LD		SP,SPSTRT		;INITIALIZE STACK POINTER
			JP		WARM01
			DS		2
WARM:		JP		WARM1			;RST 1 OR WARM START
			DS		5
RST2E:		JP		RST2V			;RST 2 TRANSFER
			DS		5
RST3E:		JP		RST3V			;RST 3 TRANSFER
			DS		5
RST4E:		JP		RST4V			;RST 4 TRANSFER
			DS		5
RST5E:		JP		RST5V			;RST 5 TRANSFER
			DS		5
RST6E:		JP		RST6V			;RST 6 TRANSFER
			DS		5
RST7E:		JP		RST7V			;RST 7 TRANSFER
			DS		5
WARM01:		LD		(SPLSAV),SP
			JP		WARM2			; GO TO COMMAND RECOGNITION
;
;
;
;WARM START SAVES THE USERS REGISTERS AND
;ENTERS THE COMMAND RECOGNITION MODE WITH
;FS DISPLAYED ON THE DATA AND ADDRESS DISPLAYS
;
WARM1:		LD		(ASAV),A 		;SAVE USERS A
			POP		HL				;GET USERS PC FROM STACK
			LD		(PCLSAV),HL		;SAVE USERS PC IN SAVE AREA
			PUSH	AF
			POP		HL				;GET USERS FLAGS
			LD		(ESAV),HL		;SAVE USERS FLAGS
			LD		(IXLSAV),IX		;SAVE USERS IX
			LD		(IYLSAV),IY		;SAVE USERS IY
			LD		(SPLSAV),SP		;SAVE USERS SP
			LD		A,I				;SAVE USERS I
			LD		(ISAV),A
			LD		A,R				;SAVE USERS R
			LD		(RSAV),A
			LD		HL,BSAV
			LD		(HL),B			;SAVE USERS B
			INC		HL
			LD		(HL),C			;SAVE USERS C
			INC		HL
			LD		(HL),D			;SAVE USERS D
			INC		HL
			LD		(HL),E			;SAVE USERS E
			EXX						;SAVE ALTERNATE REGISTERS
			PUSH	AF
			LD		(AASAV),A		;SAVE ALT A
			LD		(ALSAV),HL		;SAVE ALT H&L
			POP		HL
			LD		(AESAV),HL		;SAVE ALT FLAGS
			LD		HL,ABSAV
			LD		(HL),B			;SAVE ALT B
			INC		HL
			LD		(HL),C			;SAVE ALT C
			INC		HL
			LD		(HL),D			;SAVE ALT D 
			INC		HL
			LD		(HL),E			;SAVE ALT E 
;
;
;COMMAND RECOGNITION MODULE
;
WARM2:		CALL	CLDIS			;CLEAR DISPLAY
			LD		A,255			;DISPLAY FFFF FF
			OUT		(ADDIS1),A
			OUT		(ADDIS2),A
			OUT		(DATDIS),A
			CALL	KEYIN			;GET INPUT CHARACTER
			LD		B,MEM
			CP		B
			JP		Z,MEMORY		;JUMP IF MEMORY REQUEST
			INC		B
			CP		B
			JP		Z,REGIST		;JUMP IF REGISTER REQUEST
			INC		B
			CP		B
			JP		Z,GOREQ
			JP		WARM2
;
MEM:		EQU		64				;MEMORY KEY
;
;
;RESTART RESTORES THE USERS REGISTERS
;AND RETURNS CONTROL TO THE ADDRESS
;SPECIFIED IN THE PC SAVE LOCATION IN THE
;REGISTER SAVE AREA
;
RESTRT:		LD		A,(ABSAV)		;RESTORE ALT REGISTERS
			LD		B,A
			LD		A,(ACSAV)
			LD		C,A
			LD		A,(ADSAV)
			LD		D,A
			LD		A,(AESAV)
			LD		E,A
			LD		A,(AFSAV)
			LD		L,A
			PUSH	HL
			POP		AF
			LD		A,(AASAV)
			LD		HL,(ALSAV)
			EXX
			LD		IY,(IYLSAV)		;RESTORE IY
			LD		IX,(IXLSAV)		;RESTORE YI
			LD		HL,(ISAV)
			LD		A,(HL)
			LD		I,A
			INC		HL
			LD		A,(HL)
			LD		R,A
			LD		HL,ASAV
			LD		A,(HL)			;RESTORE A
			INC		HL
			LD		B,(HL)			;RESTORE B
			INC		HL
			LD		C,(HL)			;RESTORE C
			INC		HL
			LD		D,(HL)			;RESTORE D
			INC		HL
			LD		E,(HL)			;RESTORE E
			LD		SP,(SPLSAV)		;RESTORE STACK POINTER
			LD		HL,(PCLSAV)		;REPLACE PC ON STACK
			PUSH	HL
			LD		HL,(LSAV)		;RESTORE H&L
			RET						;RETURN TO USER
;
;;
;
;CLDIS CLEARS THE DATA AND ADDRESS DISPLAYS
;SETS THE KEYBOARD BUFFER=0 AND CLEARS THE 
;KEYOARD FLAGS
;
CLDIS:		LD		A,ZERO
			LD		(KFLAGS),A		;CLEAR FLAGS
			LD		(KDATA1),A		;CLEAR BUFFER
			LD		(KDATA2),A
			OUT		(DATDIS),A		;CLEAR DATA FIELD DISPLAY
			OUT		(ADDIS1),A		;CLEAR ADDRESS FIELD DISPLAY
			OUT		(ADDIS2),A
			RET
;
;
;KEYIN WAITS FOR INPUT FROM THE KEYBOARD
;UPON DETECTING DATA AT THE INPUT PORT (0)
;VIA THE STROBE BIT (7) BEING SET THE DATA
;IS INPUT,THE STROBE BIT CLEARED, AND THE INPUT
;CHARACTER IS RETURNED TO THE USER IN A
;
;
KEYIN:		IN		A,(KEYPT)		;INPUT DATA
			BIT		7,A
			JP		Z,KEYIN			;LOOP IF NO DATA
			LD		(TEMP),A		;SAVE CHARACTER
KEYIN1:		IN		A,(KEYPT)
			BIT		7,A
			JP		NZ,KEYIN1		;JUMP IF STROBE PRESENT
			LD		A,(TEMP)
			RES		7,A				;CLEAR STROBE
			RET
;
;
;KFLG01 SETS THE NEXT(0) AD NO DATA(2) KEYBOARD FLAGS
;
;
KFLG02:		LD		HL,KFLAGS
			SET		0,(HL)			;SET NEXT FLAG
			SET		2,(HL)
			POP		HL				;CLEAR RETURN
			RET
;
;
;KFLG0 SETS THE NEXT(0) KEYBOARD FLAG
;
;
KFLG0:		LD		HL,KFLAGS
			SET		0,(HL)			;CLEAR NEXT FLAG
			POP		HL				;CLEAR RETURN
			RET
;
;
;KFLG12 SETS THE EXEC(1) AND NO DATA(2) KEYBOARD FLAG
;
;
KFLG12:		LD		HL,KFLAGS
			SET		1,(HL)
			SET		2,(HL)
			POP		HL				;CLEAR RETURN
			RET
;
;
;KFLG1 SETS THE EXEC(1) KEYBOARD FLAG
;
;
KFLG1:		LD		HL,KFLAGS
			SET		1,(HL)			;SET EXEC FLAG
			POP		HL				;CLEAR RETURN
			RET
;
;
;ONECAR INPUTS ONE CHARACTER FOLLOWED BY A NEXT OR EXEC
;FROM THE KEYBOARD, VALIDATES IT, AND RETURNS IT TO
;THE USER IN KDATA2
;
;
ONECAR:		CALL	CLDIS			;CLEAR DISPLAY,BUFFER,&FLAGS
			CALL	KEYIN			;GET CHARACTER
			OUT		(DATDIS),A
			CALL	CARCK1			;CHECK CHARACTER
			BIT		6,A
			JP		NZ,ONECA1		;JUMP IF SHIFT
			SUB		16				;CHARACTER=0-F
			JP		P,ONECAR		;JUMP IF NOT 0-F
			ADD		16
ONECA1:		LD		(KDATA2),A		;SAVE CHARACTER
			CALL	KEYIN			;GET NEXT CHARACTER
			CALL	CARCK2
			JP		ONECA1			;GO DO AGAIN NOT EXEC OR NEXT
;
;
;CARCK1 CHECKS FOR A NEXT OR EXEC ON AN INITIAL
;CHARACTER. IF NEXT THE ROUTINE RETURNS TO THE CALLER VIA
;KFLG01. IF EXEC THE ROUTINE RETURNS TO THE CALLER
;VIA KFLG12
;
;
CARCK1:		LD		B,NEXTC			;CHECK FOR NEXT
			CP		B
			JP		Z,KFLG02		;IF NEXT JUMP
			LD		B,EXECC			;CHECK FOR EXEC
			CP		B
			JP		Z,KFLG12		;IF EXEC JUMP
			RET						;ELSE RETURN
;
;
;CARCK2 CHECKS FOR NEXT OR EXEC, SETS THE PROPER
;FLAG VIA KFLG0 OR KFLG1 AND RETURNS TO THE USER
;IF NOT NEXT OR EXEC THE ROUTINE RETURNS TO
;THE ORIGINATOR OF THE REQUEST
;
;
CARCK2:		LD		B,NEXTC			;CHECK FOR NEXT
			CP		B
			JP		Z,KFLG0			;IF NEXT JUMP
			LD		B,EXECC			;CHECK FOR EXEC
			CP		B
			JP		Z,KFLG1
			RET
;
;
;TWOCAR INPUTS 2 CHARACTERS FOR THE KEYBOARD
;FOLLOWED BY A NEXT OR EXEC AND RETURNS THEM TO THE
;USER IN KDATA2
;
;
TWOCAR:		CALL	CLDAT			;CLEAR BUFFER,FLAGS,AND DISPLAY
			CALL	KEYIN			;GET CHARACTER
			CALL	CARCK1			;CHECK FOR NEXT OR EXEC
TWOCA1:		SUB		16				;CHARACTER=0-F
			JP		TWOCAR			;JUMP IF NOT 0-F
			ADD		16
			LD		HL,KDATA2
			LD		B,(HL)			;GET OLD DATA
			RLC		B
			RLC		B
			RLC		B
			RLC		B
			ADD		A,B				;A=OLD&NEW
			OUT		(DATDIS),A		;DISPLAY INPUT
			LD		(HL),A			;SAVE NEW DATA
			CALL	KEYIN			;GET NEXT CHARACTER
			CALL	CARCK2			;CHECK FOR TERMINATION
			JP		TWOCA1			;JUMP IF NO TERMINATION
;
;
;CLDAT CLEARS THE INPUT BUFFER,FLAGS, AND DATA DIS
;
;
CLDAT:		LD		A,ZERO
			LD		(KFLAGS),A		;CLEAR FLAGS
			LD		(KDATA2),A		;CLEAR BUFFER
			LD		(KDATA1),A
			RET
CLADD:		LD		A,ZERO			;CLEAR ADDRESS DISPLAY
			OUT		(ADDIS1),A
			OUT		(ADDIS2),A
			RET
;
;
;FORCAR IMPUTS FOUR CHARACTERS FROM THE KEYBOARD
;FOLLOWED BY A NEXT OR EXEC AND RETURNS THEM
;TO THE USER IN KDATA1 AND KDATA2
;
;
FORCAR:		CALL	CLDAT			;CLEAR FLAGS AND BUFFER
			CALL	KEYIN			;GET INPUT CHARACTER
			CALL	CARCK1			;CHECK FOR NEXT OR EXEC
FORCA1:		SUB		16				;CHARACTER=0-F
			JP		P,FORCAR		;JUMP IF NOT 0-F
			ADD		16
			LD		(TEMP),A		;SAVE CHARACTER
			LD		A,(KDATA1)		;A=MSD
			LD		HL,(KDATA2)
			RRD						;ADJUST FOR NEW CHARACTER
			RLCA
			RLCA
			RLCA
			RLCA
			AND		240				;MASK OFF OLD IDGIT
			LD		HL,TEMP
			ADD		A,(HL)			;ADD IN NEW DIGIT
			LD		HL,(KDATA2)		;SAVE NEW LSDS
			LD		(KDATA1),HL		;SAVE NEW MSDS
			LD		(KDATA2),A		;SAVE NEW LSDS
			OUT		(ADDIS2),A		;DISPLAY LSDS
			LD		A,(KDATA1)
			OUT		(ADDIS1),A
			CALL	KEYIN			;GET NEXT CHARACTER
			CALL	CARCK2			;CHECK FOR NEXT OR EXEC
			JP		FORCA1			;JUMP IF NOT NEXT OR EXEC
;
;
;
;
;MEMORY INPUTS AN ADDRESS FROM THE KEYBOARD FOLLOWED
;BY DATA AS ??? BY THE SEQUENCE
; MEM(ADDRESS)NEXT,(DATA)NEXT...(DATA)EXEC
;IF DATA IS TO BE DISPLAYED
; MEM(ADDRESS)NEXT,NEXT....NEXT,EXEC
;EXEC WILL RETURN CONTROL TO THE COMMAND RECOGNITION
;
;
MEMORY:		LD		A,ZERO			;CLEAR MEMORY BASE ADDRESS
			LD		(MBASE1),A
			LD		(MBASE2),A
			CALL	CLADD
			CALL	FORCAR			;GET BASE ADDRESS
			LD		A,(KFLAGS)
			BIT		1,A
			JP		NZ,WARM2		;JUMP IF EXEC FLAG SET
			LD		A,(KDATA1)		;SAVE MEMORY ADDRESS
			LD		(MBASE2),A
			LD		A,(KDATA2)
			LD		(MBASE1),A
			LD		HL,(MBASE1)		;SET MEMORY BASE ADDRESS
MEM1:		LD		A,(HL)			;GET MEMORY DATA
			OUT	(DATDIS),A			;DISPLAY MEMORY DATA
			CALL	TWOCAR			;GET NEW DATA
			LD		A,(KFLAGS)
			BIT		2,A
			JP		Z,MEM2			;JUMP IF NO DATA
			LD		HL,(MBASE1)		;GET MEM ADDRESS
			LD		A,(KDATA2)		;GET NEW DATA
			LD		(HL),A			;REPLACE OLD DATA
			LD		A,(KFLAGS)
			BIT		1,A
			JP		NZ,WARM2		;JUMP IF EXEC FLAG SET
MEM12:		LD		HL,MBASE1		;INC BASE MEM ADD
			INC		HL
			LD		(MBASE1),HL
			LD		A,L
			OUT		(ADDIS2),A
			LD		A,H
			OUT		(ADDIS1),A
			JP		MEM1
MEM2:		BIT		1,A
			JP		NZ,WARM2		;JUMP IF EXEC FLAG SET
			JP		MEM12
;
;
;
;REGIST INPUTS A REGISTER FROM THE KEYBOARD FOLLOWED BY
;DATA AS DEFINED BY THE SEQUENCE
; REG(INIT REG)NEXT,(DATA)NEXT...(DATA)EXEC
;REGISTER SEQUENCE IS IX,IY,SP,PC,I,R,H,L,A,B,C,D,E,F,
;AL,AH,AA,AB,AC,AD,AE,AF
;IF ONLY DATA IS TO BE DISPLAYED
; REG(INIT REG)NEXT,NEXT...EXEC
;EXEC WILL RETURN CONTROL TO THE COMMAND RECOGNITION
;
;
REGIST:		CALL	ONECAR			;GET INITIAL CHARACTER
			LD		A,(KFLAGS)
			BIT		2,A
			JP		Z,WARM2			;JUMP IF NO DATA FLAG SET
			LD		A,(KDATA2)		;GET BASE REGISTER
REGI0:		LD		(TEMP2),A
			BIT		6,A				;CHECK FOR SHIFT
			JP		NZ,REGISA		;JUMP IF SHIFT KEY SET
			CP		6
			JP		P,REGI1			;JUMP ID EIGHT BIT REGISTER
			DEC		A
			DEC		A
			ADD		A				;I=(I-2)*2
			JP		REGI2
REGI1:		INC		A
			INC		A
REGI2:		LD		(REGINX),A		;SAVE INDEX
			LD		A,(TEMP2)
			CP		0x10
			JP		M,REGI2A
			BIT		6,A
			JP		NZ,REGI2A		;JUMP IF BIT 6 SET
			LD		A,0x48
			LD		(TEMP2),A
REGI2A:		OUT		(DATDIS),A		;DISPLAY REGISTER SELECT
			LD		A,(REGINX)
			CP		EIGHT
			JP		M,XYSP			;JUMP IF 16-BIT REG
			LD		HL,IXLSAV		;GET BASE ADD
			LD		C,A
			LD		B,ZERO
			ADD		HL,BC
			LD		(MBASE1),HL		;SAVE REG SAVE ADD
			LD		A,(HL)			;GET REGISTER DATA
			OUT		(ADDIS2),A		;DISPLAY DATA
			LD		A,B
			OUT		(ADDIS1),A
			CALL	TWOCAR			;GET NEW DATA
			LD		A,(KFLAGS)
			BIT		2,A
			JP		NZ,REGI3		;JUMP IF NO DATA
			LD		HL,(MBASE1)
			LD		A,(KDATA1)		;GET NEW DATA
			LD		(HL),A			;REPLACE OLD DATA
			LD		A,(KFLAGS)
			BIT		1,A
			JP		NZ,WARM2		;JUMP ID EXEC FLAG SET
REGI3:		LD		A,(TEMP2)		;INCREMENT INDEX
			INC		A
			LD		(TEMP2),A
			LD		A,(REGINX)		;INCREMENT INDEX
			INC		A
			CP		0x1A
			JP		M,REGI2			;JUMP IF INITIAL INDEX .LT. 1A 
REGI4:		LD		A,TWO			;SET INITIAL INDEX
			JP		REGI0
REGISA:		SUB		0x48
			JP		M,REGIST		;JUMP IF INVALID REGISTER
			ADD		0x12
			JP		REGI2
XYSP:		LD		HL,IXLSAV
			LD		C,A
			LD		B,ZERO
			ADD		HL,BC			;HL=REG SAVE ADDRESS
			LD		(MBASE1),HL
			LD		A,(HL)			;DISPLAY REGISTER DATA
			OUT		(ADDIS2),A
			INC		HL
			LD		A,(HL)
			OUT		(ADDIS1),A
			LD		A,(REGINX)
			INC		A
			LD		(REGINX),A
			CALL	FORCAR			;GET NEW DATA
			LD		A,(KFLAGS)
			BIT		2,A
			JP		NZ,REGI5		;JUMP IF NO DATA
			LD		HL,(MBASE1)		;REPLACE OLD DATA
			LD		A,(KDATA2)
			LD		(HL),A
			LD		A,(KDATA1)
			INC		HL
			LD		(HL),A
			LD		A,(KFLAGS)
REGI5:		BIT		1,A
			JP		NZ,WARM2		;JUMP ID EXEC FLAG SET
			JP		REGI3
;
;
;
;GO RESETS THE USERS RESTART ADDRESS IN THE
;REGISTER SAVE AREA AND EXITS TO THE RESTART
;MODULE
;
;
GOREQ:		CALL	CLADD
			CALL	FORCAR			;GET RESTART ADDRESS
			LD		A,(KFLAGS)
			BIT		2,A
			JP		NZ,WARM2		;IF NO DATA EXIT
			LD		A,(KDATA2)		;SAVE NEW ADDRESS
			LD		(PCLSAV),A
			LD		A,(KDATA1)
			LD		(PCHSAV),A
			JP		RESTRT
;
;
;
;UATST IS A UART LOOP CHECK ROUTINE
;IT UTILIZES A LOOP WITH THE OUTPUT
;PORT PATCHED TO THE INPUT PORT
;IF AN ERROR IS DETECTED THE ERROR OS
;DISPLYED ON THE ADDRESS DISPLAY AND
;THE CHARACTER IS DISPLAYED ON THE DATA DISPLAY
;THE OUTPUR CHARACTE IS DISPLAYED ON THE MSD
;OF THE ADDRESS DISPLAY
;
UATST:		LD		B,ZERO			;
			IN		A,(UARTST)		;GET STATUS
			BIT		0,A
			JP		Z,UAER1			;JUMP IF XMIT BUFFER NOT EMPTY
UATST0:		LD		A,B				;GET OUTPUT CHARACTER
			OUT		(ADDIS1),A
			OUT		(UARTIO),A
UATST1:		IN		A,(UARTST)
			BIT		1,A
			JP		Z,UATST1		;JUMP IF NO DATA AVAILABLE
			AND		0x1C
			JP		NZ,UAER1		;JUMP IF PARITY ERROR
			IN		A,(UARTIO)		;GET INPUT CHARACTER
			OUT		(DATDIS),A
			CP		B
			JP		NZ,UAER2		;JUMP IF INPUT.NE.OUTPUT
			INC		B
			JP		UATST0
UAER1:		OUT		(ADDIS2),A		;DISPLAY UART STATUS
			IN		A,(UARTIO)		;GET INPUT DATA
			OUT		(DATDIS),A
			HALT
UAER2:		LD		A,0x0F
			OUT		(ADDIS2),A
			HALT
;
;
;TTYINPUT DRIVER
;INPUTS DATA INTO THE SPECIFIED BUFFER
;INPUT IS TERMINATED WHEN A CARRIAGE RETURN
;IS DETECTED OR THE NUMBER OF SPECIFIED CHARACTERS
;HAVE BEEN INPUTTED FROM THE TRANSMITTING DEVICE
;
TTYINP:		LD		HL,(TTYIBF)		;GET BUFFER ADDRESC
			LD		A,(TTYIC)		;GET NUMBER OF CHARACTERS
			LD		B,A
TTYIN1:		IN		A,(UARTST)		;GET UART STATUS
			BIT		1,A
			JP		Z,TTYIN1		;JUMP IF NO DATA
			AND		0x1C
			JP		NZ,TTYERR		;JUMP IF PARITY ERROR
			IN		A,(UARTIO)		;GET INPUT CHARACTER
			LD		(HL),A			;SAVE CHARACTER IN USERS BUF
			CP		0x0D
			JP		Z,TTYIN2		;JUMP IF CARRIAGE RETURN
			LD		A,ONE			;SET OUTPUT CHARACTER COUNT
TTYIN3:		LD		(TTYOBF),HL		;SET OUTPUT BUFFE ADDRESS
			LD		(TTYOC),A
			LD		A,B
			LD		(TEMP),A
			DEC		B
			RET		Z				;RETURN IF ALL CHARACTERS IN
			JP		TTYIN1
TTYIN2:		LD		HL,LF			;GET LINE FEED ADDRESS
			LD		A,TWO
			LD		B,ONE
			JP		TTYIN3
TTYERR:		RET
LF:			DB		0x0D,0x0A
;
;TTY OUTPUT DRIVER
;TTYOUT OUTPUTS DATA FROM THE SPECIFIED
;USERS BUFFER TO THE UART. THE NUMBER OF
;USER SPECIFIED CHARACTES ARE OUTPUT
;AND CONTROL RETURNED TO THE USER
;
TTYOUT:		LD		HL,(TTYOBF)		;GET BUFFER ADDRESS
			LD		A,(TTYOC)		;GET NUMBER OF CHARACTERS
			LD		B,A
TTYOU1:		LD		C,ZERO
			LD		DE,ZERO
TTYO1:		IN		A,(UARTST)		;GET STATUS
			BIT		0,A
			JP		Z,TTYOU2		;JUMP IF BUFFER NOT EMPTY
			LD		A,(HL)			;GET CHARACTER
			OUT		(UARTIO),A		;OUTPUT CHARACTER
			DEC		B
			LD		A,ZERO
			RET		Z				;RETURN IF BUFFER EMPTY
			INC		HL
			JP		TTYOU1
TTYOU2:		INC		DE				;TRY AGAIN DELAY
			LD		A,E
			CP		ZERO
			JP		NZ,TTYOU2
			LD		A,D
			CP		ZERO
			JP		NZ,TTYOU2
			INC		C
			CP		FIVE
			JP		NZ,TTYO1		;JUMP IF .LT.5 TRYS
			LD		A,ONE			;ELSE RETURN WITH A=1
			RET
;
			ORG		0x7C4
;
;PAGE 2 CONSTANS,JUMP AREAS,AND REGISTER
;SAVE AREAS
;
SPSTRT:		DB		0
;
;USER RESTART AREA
;
RST2V:		DS		3
RST3V:		DS		3
RST4V:		DS		3
RST5V:		DS		3
RST6V:		DS		3
RST7V:		DS		3
;
;REGISTER SAVE AREA
;
IXLSAV:		DB		0
IXHSAV:		DB		0
IYLSAV:		DB		0
IYHSAV:		DB		0
SPLSAV:		DB		0
SPHSAV:		DB		0
PCLSAV:		DB		0
PCHSAV:		DB		0
ISAV:		DB		0
RSAV:		DB		0
LSAV:		DB		0
HSAV:		DB		0
ASAV:		DB		0
BSAV:		DB		0
CSAV:		DB		0
DSAV:		DB		0
ESAV:		DB		0
FSAV:		DB		0
ALSAV:		DB		0
AHSAV:		DB		0
AASAV:		DB		0
ABSAV:		DB		0
ACSAV:		DB		0
ADSAV:		DB		0
AESAV:		DB		0
AFSAV:		DB		0
;
;DATA STORAGE AREAS
;
KFLAGS:		DB		0				;KEYBOARD FLAGS
KDATA1:		DB		0				;KEYBOARD INPUT BUFFER
KDATA2:		DB		0
TEMP:		DB		0
TEMP2:		DB		0
MBASE1:		DB		0				;BASE MEMORY ADDRESS
MBASE2:		DB		0
REGINX:		DB		0				;REGISTER INDEX
TTYIBF:		DS		2				;TTY INPUT BUFFER ADDRESS
TTYOBF:		DS		2				;TTYOUTPUT BUFFER ADDRESS
TTYIC:		DB		0				;TTY INPUT CHARACTER COUNT
TTYOC:		DB		0				;TTY OUTPUT CHARACTER COUNT
;

